---
title: Queues & Stream Processing
description: Decouple producers from consumers using message queues and event streams
type: pattern
category: specialized
difficulty: intermediate
reading_time: 35 min
prerequisites: 
when_to_use: Handling traffic spikes, decoupling services, event streaming, work distribution
when_not_to_use: Synchronous request-response, low latency requirements, simple direct calls
status: complete
last_updated: 2025-07-21
---
# Queues & Stream Processing



## The Essential Question

**How can we handle variable workloads and protect services from being overwhelmed while maintaining system reliability?**

---

## Level 1: Intuition (5 minutes)

### The Story

Friday night restaurant without queues: overwhelmed servers, swamped kitchen, indefinite waits, blocking.

With a host managing a waiting list: numbered check-ins, sustainable pace, multiple servers, handled rushes.

Queues do the same for software.

### Visual Metaphor

```
Without Queues:                    With Queues:

Client → Service → Database        Client → Queue → Service → Database
Client → Service ✗ (Overload)               ↓        ↓
Client → Service ✗ (Timeout)          Buffer spikes  Process at own pace
Client → Service ✗ (Failed)                 ↓        ↓
                                     Never lost    Scale independently
Chaos and failures                 Orderly and resilient
```

### In One Sentence

**Queues & Streams**: Buffer work between producers/consumers for independent pacing with durability and scale.

### Real-World Parallel

Like factory assembly lines - controlled pace, adjustable workers, continuous flow despite slowdowns.

---

## Level 2: Foundation (10 minutes)

### The Problem Space

<div class="failure-vignette">
<h4>🔥 Without Queues: Instagram Explore Meltdown</h4>
Explore launch with direct calls + viral moment:
- 100x traffic spike
- ML servers overwhelmed
- Cascading failures
- 4-hour outage, 500M users
- $2M+ lost revenue

Queues would have absorbed and gradually processed the spike.
</div>

### Core Concept

Queue/stream benefits:

1. **Temporal Decoupling**: Independent producer/consumer operation
2. **Load Leveling**: Absorb spikes
3. **Reliability**: Persistent messages
4. **Scalability**: Dynamic consumers
5. **Ordering**: Maintained when needed

### Basic Architecture

```mermaid
graph LR
    subgraph "Queue Patterns"
        subgraph "Point-to-Point"
            P1[Producer] --> Q1[Queue]
            Q1 --> C1[Consumer 1]
            Q1 --> C2[Consumer 2]
        end
        
        subgraph "Publish-Subscribe"
            P2[Producer] --> T[Topic]
            T --> S1[Subscriber 1]
            T --> S2[Subscriber 2]
            T --> S3[Subscriber 3]
        end
        
        subgraph "Stream Processing"
            P3[Producer] --> L[Log]
            L --> SP1[Stream Processor 1]
            L --> SP2[Stream Processor 2]
            SP1 --> O[Output]
        end
    end
    
    style Q1 fill:#bbf,stroke:#333,stroke-width:2px
    style T fill:#f9f,stroke:#333,stroke-width:2px
    style L fill:#9f9,stroke:#333,stroke-width:2px
```

### Message Flow Patterns

```mermaid
sequenceDiagram
    participant P as Producer
    participant Q as Queue
    participant C1 as Consumer 1
    participant C2 as Consumer 2
    
    Note over P,C2: Point-to-Point Pattern
    P->>Q: Send Message A
    P->>Q: Send Message B
    Q->>C1: Deliver Message A
    Q->>C2: Deliver Message B
    C1->>Q: ACK Message A
    C2->>Q: ACK Message B
    
    Note over P,C2: Load Distribution
    P->>Q: Send Message C
    P->>Q: Send Message D
    Q->>C1: Deliver Message C (Round Robin)
    Q->>C2: Deliver Message D (Round Robin)
```

### Key Benefits

1. **Resilience**: Works despite consumer downtime
2. **Elasticity**: Queue-based scaling
3. **Buffering**: No dropped requests
4. **Replay**: Stream reprocessing

### Trade-offs

| Aspect | Gain | Cost |
|--------|------|------|
| Coupling | Loose coupling | Additional complexity |
| Reliability | Message durability | Storage overhead |
| Scalability | Independent scaling | Queue management |
| Latency | Consistent processing | Added hop latency |

---

## Level 3: Deep Dive (20 minutes)

### Detailed Architecture

```mermaid
graph TB
    subgraph "Producers"
        P1[Web API]
        P2[Mobile API]
        P3[Batch Job]
        P4[IoT Devices]
    end
    
    subgraph "Message Infrastructure"
        subgraph "Queue System"
            B[Message Broker]
            Q1[Order Queue]
            Q2[Email Queue]
            Q3[Analytics Queue]
            DLQ[Dead Letter Queue]
        end
        
        subgraph "Stream System"
            K[Kafka/Event Stream]
            P[Partitions]
            CG[Consumer Groups]
        end
    end
    
    subgraph "Consumers"
        subgraph "Queue Consumers"
            C1[Order Processor]
            C2[Email Sender]
            C3[Analytics Writer]
        end
        
        subgraph "Stream Processors"
            SP1[Real-time Analytics]
            SP2[Event Sourcing]
            SP3[CDC Processor]
        end
    end
    
    subgraph "Storage"
        DB[(Database)]
        S3[(Object Store)]
        DW[(Data Warehouse)]
    end
    
    P1 --> B
    P2 --> B
    P3 --> K
    P4 --> K
    
    B --> Q1 --> C1 --> DB
    B --> Q2 --> C2
    B --> Q3 --> C3 --> DW
    
    K --> P --> CG
    CG --> SP1 --> DW
    CG --> SP2 --> DB
    CG --> SP3 --> S3
    
    Q1 -.->|Failed| DLQ
    Q2 -.->|Failed| DLQ
    
    style B fill:#bbf,stroke:#333,stroke-width:3px
    style K fill:#9f9,stroke:#333,stroke-width:3px
    style DLQ fill:#f99,stroke:#333,stroke-width:2px
```

### Implementation Patterns

#### Queue Implementation Patterns

##### Message Flow Sequence

```mermaid
sequenceDiagram
    participant App as Application
    participant Q as Queue Manager
    participant S as Storage
    participant C as Consumer
    
    App->>Q: send(message)
    Q->>Q: Generate Message ID
    Q->>S: Store Message
    Q-->>App: Return Message ID
    
    C->>Q: receive()
    Q->>S: Get Next Message
    S-->>Q: Message Data
    Q->>Q: Set Visibility Timeout
    Q-->>C: Return Message
    
    alt Success
        C->>Q: delete(messageId)
        Q->>S: Remove Message
    else Failure
        Note over Q,S: Visibility timeout expires
        Q->>Q: Make message available again
    end
```

##### Queue State Machine

```mermaid
stateDiagram-v2
    [*] --> Available: Message Sent
    Available --> InFlight: Consumer Receives
    InFlight --> Processed: ACK Received
    InFlight --> Available: Visibility Timeout
    InFlight --> DeadLetter: Max Retries Exceeded
    Processed --> [*]: Deleted
    DeadLetter --> [*]: Manual Intervention
    
    note right of InFlight
        Message locked for
        visibility timeout period
    end note
    
    note right of DeadLetter
        Poison messages that
        repeatedly fail processing
    end note
```

##### Core Queue Operations

```python
from abc import ABC, abstractmethod
from collections import deque
from threading import Lock, Event
from typing import Any, Optional, Dict, List, Callable
from dataclasses import dataclass
from datetime import datetime, timedelta
import json
import time
import uuid

@dataclass
class Message:
    """Message with metadata"""
    id: str
    body: Any
    timestamp: datetime
    attributes: Dict[str, str]
    attempt_count: int = 0
    
    def __post_init__(self):
        if not self.id:
            self.id = str(uuid.uuid4())
        if not self.timestamp:
            self.timestamp = datetime.utcnow()

class Queue(ABC):
    """Abstract queue interface"""
    
    @abstractmethod
    async def send(self, message: Any, **kwargs) -> str:
        pass
    
    @abstractmethod
    async def receive(self, max_messages: int = 1, 
                     timeout: int = 30) -> List[Message]:
        pass
    
    @abstractmethod
    async def delete(self, message_id: str) -> bool:
        pass
    
    @abstractmethod
    async def get_depth(self) -> int:
        pass

class InMemoryQueue(Queue):
    """Thread-safe in-memory queue implementation"""
    
    def __init__(self, max_size: int = 10000):
        self.queue = deque()
        self.max_size = max_size
        self.lock = Lock()
        self.not_empty = Event()
        self.in_flight: Dict[str, Message] = {}
        self.dead_letter_queue = deque()
        self.max_attempts = 3
        
    async def send(self, message: Any, delay: int = 0, **kwargs) -> str:
        """Send message to queue"""
        with self.lock:
            if len(self.queue) >= self.max_size:
                raise QueueFullError(f"Queue at capacity: {self.max_size}")
            
            msg = Message(
                id=str(uuid.uuid4()),
                body=message,
                timestamp=datetime.utcnow() + timedelta(seconds=delay),
                attributes=kwargs
            )
            
            self.queue.append(msg)
            self.not_empty.set()
            
            return msg.id
    
    async def receive(self, max_messages: int = 1, 
                     timeout: int = 30) -> List[Message]:
        """Receive messages from queue"""
        messages = []
        deadline = time.time() + timeout
        
        while len(messages) < max_messages and time.time() < deadline:
            with self.lock:
                # Skip messages with future timestamps (delayed)
                now = datetime.utcnow()
                available_messages = [
                    msg for msg in self.queue 
                    if msg.timestamp <= now
                ]
                
                if available_messages:
                    msg = available_messages[0]
                    self.queue.remove(msg)
                    
                    msg.attempt_count += 1
                    self.in_flight[msg.id] = msg
                    messages.append(msg)
                    
                    if not self.queue:
                        self.not_empty.clear()
                else:
                    # Wait for messages
                    remaining = deadline - time.time()
                    if remaining > 0:
                        self.not_empty.wait(min(remaining, 1))
        
        return messages
    
    async def delete(self, message_id: str) -> bool:
        """Acknowledge message processing"""
        with self.lock:
            if message_id in self.in_flight:
                del self.in_flight[message_id]
                return True
            return False
    
    async def visibility_timeout_expired(self):
        """Return unacknowledged messages to queue"""
        with self.lock:
            now = datetime.utcnow()
            expired = []
            
            for msg_id, msg in self.in_flight.items():
                # 30 second visibility timeout
                if (now - msg.timestamp).seconds > 30:
                    expired.append(msg_id)
            
            for msg_id in expired:
                msg = self.in_flight.pop(msg_id)
                
                if msg.attempt_count >= self.max_attempts:
                    # Move to DLQ
                    self.dead_letter_queue.append(msg)
                else:
                    # Requeue with exponential backoff
                    delay = 2 ** (msg.attempt_count - 1)
                    msg.timestamp = now + timedelta(seconds=delay)
                    self.queue.append(msg)
                    self.not_empty.set()
    
    async def get_depth(self) -> int:
        """Get number of messages in queue"""
        with self.lock:
            return len(self.queue)

##### Stream Processing Architecture

```mermaid
graph TB
    subgraph "Stream Processing Flow"
        P[Producers] --> PS[Partitioned Stream]
        PS --> CG1[Consumer Group 1]
        PS --> CG2[Consumer Group 2]
        
        subgraph "Partitions"
            PS --> P0[Partition 0]
            PS --> P1[Partition 1]
            PS --> P2[Partition 2]
        end
        
        subgraph "Consumer Group 1"
            P0 --> C1A[Consumer 1A]
            P1 --> C1B[Consumer 1B]
            P2 --> C1C[Consumer 1C]
        end
        
        subgraph "Consumer Group 2"
            P0 --> C2A[Consumer 2A]
            P1 --> C2A
            P2 --> C2B[Consumer 2B]
        end
    end
```

##### Stream Event Flow

```mermaid
sequenceDiagram
    participant P as Producer
    participant S as Stream
    participant Part as Partition Router
    participant P0 as Partition 0
    participant P1 as Partition 1
    participant CG as Consumer Group
    
    P->>S: Produce(key=user123, value=event)
    S->>Part: Route by key hash
    Part->>Part: hash(user123) % 2 = 1
    Part->>P1: Append to Partition 1
    P1->>P1: Assign offset=42
    P1-->>S: Return (partition=1, offset=42)
    S-->>P: ACK with position
    
    CG->>S: Poll for new events
    S->>P1: Read from last offset
    P1-->>CG: Events from offset 41
    CG->>CG: Process events
    CG->>S: Commit offset 42
```

# Stream Processing Implementation
class StreamPartition:
    """Single partition of an event stream"""
    
    def __init__(self, partition_id: int):
        self.partition_id = partition_id
        self.events: List[Dict[str, Any]] = []
        self.lock = Lock()
        
    def append(self, key: str, value: Any) -> int:
        """Append event to partition"""
        with self.lock:
            offset = len(self.events)
            self.events.append({
                'offset': offset,
                'key': key,
                'value': value,
                'timestamp': datetime.utcnow(),
                'partition': self.partition_id
            })
            return offset
    
    def read(self, start_offset: int, max_events: int = 100) -> List[Dict]:
        """Read events from offset"""
        with self.lock:
            end_offset = min(start_offset + max_events, len(self.events))
            return self.events[start_offset:end_offset]

class EventStream:
    """Distributed event stream (like Kafka)"""
    
    def __init__(self, num_partitions: int = 16):
        self.partitions = [
            StreamPartition(i) for i in range(num_partitions)
        ]
        self.consumer_groups: Dict[str, Dict[int, int]] = {}
        
    def produce(self, topic: str, key: str, value: Any) -> tuple:
        """Produce event to stream"""
        # Partition by key for ordering
        partition_id = hash(key) % len(self.partitions)
        partition = self.partitions[partition_id]
        
        event = {
            'topic': topic,
            'key': key,
            'value': value,
            'headers': {}
        }
        
        offset = partition.append(key, event)
        return partition_id, offset
    
    def subscribe(self, consumer_group: str, 
                  partitions: Optional[List[int]] = None):
        """Subscribe to partitions as consumer group"""
        if partitions is None:
            partitions = list(range(len(self.partitions)))
            
        if consumer_group not in self.consumer_groups:
            self.consumer_groups[consumer_group] = {
                p: 0 for p in partitions
            }
    
    def consume(self, consumer_group: str, 
                max_events: int = 100) -> List[Dict]:
        """Consume events as part of consumer group"""
        if consumer_group not in self.consumer_groups:
            raise ValueError(f"Consumer group {consumer_group} not subscribed")
        
        events = []
        group_offsets = self.consumer_groups[consumer_group]
        
        for partition_id, offset in group_offsets.items():
            partition = self.partitions[partition_id]
            partition_events = partition.read(offset, max_events)
            
            if partition_events:
                events.extend(partition_events)
                # Update consumer group offset
                new_offset = partition_events[-1]['offset'] + 1
                self.consumer_groups[consumer_group][partition_id] = new_offset
        
        return events
```

### Queue Technology Comparison

| Technology | Type | Throughput | Latency | Durability | Best For |
|------------|------|------------|---------|------------|----------|
| **RabbitMQ** | Message Queue | 50K msg/s | <1ms | Configurable | Traditional enterprise |
| **Kafka** | Event Stream | 1M+ msg/s | 2-5ms | Replicated | High-volume streaming |
| **SQS** | Managed Queue | 3K msg/s | 10-100ms | High | AWS integration |
| **Redis Streams** | In-memory Stream | 100K msg/s | <1ms | Optional | Real-time, cache |
| **Pulsar** | Multi-tenant Stream | 1M+ msg/s | 5-10ms | Tiered | Multi-tenancy |
| **NATS** | Message Queue | 200K msg/s | <1ms | Optional | Microservices |

### Message Pattern Decision Matrix

| Requirement | Queue | Pub/Sub | Stream | Recommendation |
|-------------|-------|---------|--------|----------------|
| Task distribution | ✓✓✓ | ✓ | ✓ | Use Queue |
| Event broadcasting | ✓ | ✓✓✓ | ✓✓ | Use Pub/Sub |
| Event replay | ✗ | ✗ | ✓✓✓ | Use Stream |
| Ordered processing | ✓ | ✓ | ✓✓✓ | Use Stream with partitions |
| At-most-once | ✓✓✓ | ✓✓✓ | ✓ | Use Queue/Pub/Sub |
| Exactly-once | ✓ | ✓ | ✓✓✓ | Use Stream with transactions |

#### Production-Ready Implementation

```python
import asyncio
import aiokafka
from aiokafka import AIOKafkaProducer, AIOKafkaConsumer
from typing import Optional, Dict, List, Callable, Any
import boto3
from botocore.exceptions import ClientError
import logging

class KafkaStreamProcessor:
    """Production Kafka stream processor"""
    
    def __init__(self, bootstrap_servers: str, 
                 consumer_group: str,
                 topics: List[str]):
        self.bootstrap_servers = bootstrap_servers
        self.consumer_group = consumer_group
        self.topics = topics
        self.producer: Optional[AIOKafkaProducer] = None
        self.consumer: Optional[AIOKafkaConsumer] = None
        self.processors: Dict[str, Callable] = {}
        self.running = False
        self.logger = logging.getLogger(__name__)
        
    async def start(self):
        """Start the stream processor"""
        # Initialize producer
        self.producer = AIOKafkaProducer(
            bootstrap_servers=self.bootstrap_servers,
            value_serializer=lambda v: json.dumps(v).encode(),
            compression_type="snappy",
            acks='all',  # Wait for all replicas
            retries=5
        )
        await self.producer.start()
        
        # Initialize consumer
        self.consumer = AIOKafkaConsumer(
            *self.topics,
            bootstrap_servers=self.bootstrap_servers,
            consumer_group=self.consumer_group,
            value_deserializer=lambda v: json.loads(v.decode()),
            auto_offset_reset='earliest',
            enable_auto_commit=False,  # Manual commit for exactly-once
            max_poll_records=100
        )
        await self.consumer.start()
        
        self.running = True
        
    async def stop(self):
        """Stop the stream processor"""
        self.running = False
        
        if self.producer:
            await self.producer.stop()
        if self.consumer:
            await self.consumer.stop()
            
    def register_processor(self, topic: str, processor: Callable):
        """Register a processor for a topic"""
        self.processors[topic] = processor
        
    async def process_stream(self):
        """Main processing loop"""
        try:
            async for msg in self.consumer:
                if not self.running:
                    break
                    
                try:
                    # Get processor for topic
                    processor = self.processors.get(msg.topic)
                    if not processor:
                        self.logger.warning(f"No processor for topic {msg.topic}")
                        continue
                    
                    # Process message
                    result = await processor(msg.value)
                    
                    # Produce result if needed
                    if result and isinstance(result, dict):
                        output_topic = result.get('topic')
                        if output_topic:
                            await self.producer.send(
                                output_topic,
                                value=result.get('value'),
                                key=result.get('key', msg.key)
                            )
                    
                    # Commit offset after successful processing
                    await self.consumer.commit()
                    
                except Exception as e:
                    self.logger.error(f"Error processing message: {e}")
                    # Could implement retry logic or DLQ here
                    
        except Exception as e:
            self.logger.error(f"Stream processing error: {e}")
            raise

# AWS SQS Queue Implementation
class SQSQueue(Queue):
    """Production-ready AWS SQS queue"""
    
    def __init__(self, queue_url: str, 
                 visibility_timeout: int = 30,
                 max_receive_count: int = 3):
        self.queue_url = queue_url
        self.visibility_timeout = visibility_timeout
        self.sqs = boto3.client('sqs')
        
        # Get queue attributes
        response = self.sqs.get_queue_attributes(
            QueueUrl=queue_url,
            AttributeNames=['All']
        )
        self.queue_arn = response['Attributes']['QueueArn']
        
        # Setup DLQ if not exists
        self._setup_dlq(max_receive_count)
        
    def _setup_dlq(self, max_receive_count: int):
        """Setup dead letter queue"""
        dlq_name = f"{self.queue_url.split('/')[-1]}-dlq"
        
        try:
            # Create DLQ
            response = self.sqs.create_queue(
                QueueName=dlq_name,
                Attributes={
                    'MessageRetentionPeriod': '1209600'  # 14 days
                }
            )
            dlq_url = response['QueueUrl']
            
            # Get DLQ ARN
            dlq_attrs = self.sqs.get_queue_attributes(
                QueueUrl=dlq_url,
                AttributeNames=['QueueArn']
            )
            dlq_arn = dlq_attrs['Attributes']['QueueArn']
            
            # Configure main queue redrive policy
            self.sqs.set_queue_attributes(
                QueueUrl=self.queue_url,
                Attributes={
                    'RedrivePolicy': json.dumps({
                        'deadLetterTargetArn': dlq_arn,
                        'maxReceiveCount': max_receive_count
                    })
                }
            )
            
        except ClientError as e:
            if e.response['Error']['Code'] != 'QueueAlreadyExists':
                raise
                
    async def send(self, message: Any, delay: int = 0, **kwargs) -> str:
        """Send message to SQS"""
        try:
            response = self.sqs.send_message(
                QueueUrl=self.queue_url,
                MessageBody=json.dumps(message),
                DelaySeconds=delay,
                MessageAttributes={
                    k: {'StringValue': str(v), 'DataType': 'String'}
                    for k, v in kwargs.items()
                }
            )
            return response['MessageId']
            
        except ClientError as e:
            self.logger.error(f"Failed to send message: {e}")
            raise
            
    async def receive(self, max_messages: int = 1, 
                     timeout: int = 30) -> List[Message]:
        """Receive messages from SQS"""
        try:
            response = self.sqs.receive_message(
                QueueUrl=self.queue_url,
                MaxNumberOfMessages=min(max_messages, 10),  # SQS limit
                WaitTimeSeconds=min(timeout, 20),  # Long polling
                VisibilityTimeout=self.visibility_timeout,
                AttributeNames=['All'],
                MessageAttributeNames=['All']
            )
            
            messages = []
            for msg in response.get('Messages', []):
                messages.append(Message(
                    id=msg['MessageId'],
                    body=json.loads(msg['Body']),
                    timestamp=datetime.fromtimestamp(
                        int(msg['Attributes']['SentTimestamp']) / 1000
                    ),
                    attributes=msg.get('MessageAttributes', {}),
                    attempt_count=int(
                        msg['Attributes'].get('ApproximateReceiveCount', 0)
                    )
                ))
                
            return messages
            
        except ClientError as e:
            self.logger.error(f"Failed to receive messages: {e}")
            raise

# Stream Processing Patterns
class StreamAggregator:
    """Aggregate events in time windows"""
    
    def __init__(self, window_size: timedelta):
        self.window_size = window_size
        self.windows: Dict[datetime, Dict[str, Any]] = {}
        
    async def process(self, event: Dict[str, Any]) -> Optional[Dict]:
        """Process event and emit aggregates"""
        timestamp = event['timestamp']
        window_start = self._get_window_start(timestamp)
        
        # Initialize window if needed
        if window_start not in self.windows:
            self.windows[window_start] = {
                'count': 0,
                'sum': 0,
                'values': []
            }
        
        # Update aggregates
        window = self.windows[window_start]
        window['count'] += 1
        
        value = event.get('value', 0)
        if isinstance(value, (int, float)):
            window['sum'] += value
            window['values'].append(value)
        
        # Check if window is complete
        if timestamp >= window_start + self.window_size:
            # Emit aggregate
            result = {
                'window_start': window_start,
                'window_end': window_start + self.window_size,
                'count': window['count'],
                'sum': window['sum'],
                'avg': window['sum'] / window['count'] if window['count'] > 0 else 0,
                'min': min(window['values']) if window['values'] else None,
                'max': max(window['values']) if window['values'] else None
            }
            
            # Clean up old window
            del self.windows[window_start]
            
            return result
            
        return None
    
    def _get_window_start(self, timestamp: datetime) -> datetime:
        """Get start of window for timestamp"""
        window_seconds = int(self.window_size.total_seconds())
        epoch = int(timestamp.timestamp())
        window_start_epoch = (epoch // window_seconds) * window_seconds
        return datetime.fromtimestamp(window_start_epoch)
```

### State Management

Queue and stream systems manage state differently:

```mermaid
stateDiagram-v2
    [*] --> Produced: Message Sent
    
    Produced --> Queued: In Queue
    Queued --> Processing: Consumer Receives
    Processing --> Processed: Success
    Processing --> Failed: Error
    
    Failed --> Queued: Retry
    Failed --> DLQ: Max Retries
    
    Processed --> [*]: Acknowledged
    DLQ --> [*]: Manual Intervention
    
    note right of Processing
        Visibility timeout prevents
        other consumers from
        receiving same message
    end note
    
    note right of DLQ
        Dead Letter Queue
        for poison messages
    end note
```

### Queue vs Stream Comparison

| Aspect | Message Queue | Event Stream |
|--------|--------------|-------------|
| **Message Retention** | Deleted after consumption | Retained for configured period |
| **Consumer Model** | Competing consumers | Consumer groups with offsets |
| **Message Order** | Best effort (FIFO) | Guaranteed within partition |
| **Replay** | Not supported | Full replay from any offset |
| **Scaling** | Add more consumers | Add partitions and consumers |
| **Use Cases** | Task distribution, commands | Event sourcing, audit logs |
| **Delivery** | At-least-once typical | Exactly-once possible |
| **Performance** | Lower latency | Higher throughput |

### Common Variations

1. **Work Queues**: Task distribution → Simple, no broadcast
2. **Pub/Sub Topics**: Fan-out → All get all messages
3. **Event Streams**: Sourcing/analytics → Complex but replayable

### Integration Points

- **CQRS**: Commands via queues, queries from reads
- **Event Sourcing**: Stream as event store
- **Saga**: Orchestration messages
- **Circuit Breaker**: Consumer protection

---

## Level 4: Expert Practitioner (30 minutes)

### Advanced Techniques

#### Exactly-Once Processing

```python
class ExactlyOnceProcessor:
    """Ensure exactly-once message processing"""
    
    def __init__(self, state_store, processor_func):
        self.state_store = state_store
        self.processor = processor_func
        
    async def process_message(self, message: Message) -> Any:
        """Process with idempotency"""
        # Check if already processed
        process_key = f"processed:{message.id}"
        
        async with self.state_store.transaction() as tx:
            # Check idempotency
            already_processed = await tx.get(process_key)
            if already_processed:
                return json.loads(already_processed)
            
            # Process message
            result = await self.processor(message)
            
            # Store result atomically
            await tx.set(process_key, json.dumps(result))
            await tx.commit()
            
        return result

# Priority Queue Implementation
class PriorityQueue:
    """Queue with message priorities"""
    
    def __init__(self, priorities: List[str] = ['high', 'normal', 'low']):
        self.priorities = priorities
        self.queues = {p: deque() for p in priorities}
        self.lock = Lock()
        
    async def send(self, message: Any, priority: str = 'normal'):
        """Send with priority"""
        if priority not in self.priorities:
            raise ValueError(f"Invalid priority: {priority}")
            
        with self.lock:
            self.queues[priority].append(message)
            
    async def receive(self) -> Optional[Message]:
        """Receive highest priority message"""
        with self.lock:
            for priority in self.priorities:
                if self.queues[priority]:
                    return self.queues[priority].popleft()
        return None
```

#### Stream Joins and Windows

```python
class StreamJoiner:
    """Join multiple streams"""
    
    def __init__(self, join_window: timedelta):
        self.join_window = join_window
        self.left_buffer: Dict[str, List[Dict]] = defaultdict(list)
        self.right_buffer: Dict[str, List[Dict]] = defaultdict(list)
        
    async def process_left(self, event: Dict) -> List[Dict]:
        """Process event from left stream"""
        key = event['key']
        timestamp = event['timestamp']
        
        # Add to buffer
        self.left_buffer[key].append(event)
        
        # Clean old events
        cutoff = timestamp - self.join_window
        self.left_buffer[key] = [
            e for e in self.left_buffer[key]
            if e['timestamp'] > cutoff
        ]
        
        # Join with right stream
        results = []
        for right_event in self.right_buffer.get(key, []):
            if abs((right_event['timestamp'] - timestamp).total_seconds()) < \
               self.join_window.total_seconds():
                results.append({
                    'key': key,
                    'left': event,
                    'right': right_event,
                    'timestamp': max(event['timestamp'], right_event['timestamp'])
                })
                
        return results
```

### Performance Optimization

<div class="decision-box">
<h4>🎯 Performance Tuning Checklist</h4>

- [ ] **Batch Processing**: Process multiple messages per receive
- [ ] **Connection Pooling**: Reuse connections to queue service
- [ ] **Compression**: Compress large messages
- [ ] **Partitioning**: Distribute load across partitions
- [ ] **Prefetch**: Optimize consumer prefetch count
- [ ] **Async I/O**: Non-blocking message processing
- [ ] **Circuit Breakers**: Protect downstream services
- [ ] **Monitoring**: Track queue depth and latency
</div>

### Monitoring & Observability

Key metrics to track:

```yaml
metrics:
  # Queue Metrics
  - name: queue_depth
    description: Number of messages in queue
    alert_threshold: > 10000
    
  - name: message_age
    description: Age of oldest message
    alert_threshold: > 5m
    
  - name: send_rate
    description: Messages sent per second
    alert_threshold: > 10000/s
    
  - name: receive_rate
    description: Messages received per second
    alert_threshold: < 100/s
    
  # Processing Metrics
  - name: processing_time
    description: Time to process message
    alert_threshold: p99 > 1s
    
  - name: error_rate
    description: Failed message percentage
    alert_threshold: > 1%
    
  - name: dlq_depth
    description: Dead letter queue size
    alert_threshold: > 100
    
  # Stream Metrics
  - name: consumer_lag
    description: Offset lag per partition
    alert_threshold: > 10000
    
  - name: partition_skew
    description: Uneven partition distribution
    alert_threshold: > 50%
```

### Common Pitfalls

<div class="failure-vignette">
<h4>⚠️ Pitfall: Poison Messages</h4>
Malformed message crashed consumers repeatedly, blocked entire queue.

**Solution**: Retry limits, DLQ, message validation.
</div>

<div class="failure-vignette">
<h4>⚠️ Pitfall: Unbounded Queue Growth</h4>
Traffic spike → Unbounded growth → Memory exhaustion → Crash.

**Solution**: Size limits, backpressure, depth monitoring.
</div>

### Production Checklist

- [ ] **Message validation** before processing
- [ ] **Dead letter queue** configured
- [ ] **Retry policy** with exponential backoff
- [ ] **Monitoring** for queue depth and consumer lag
- [ ] **Alerting** for queue issues
- [ ] **Scaling policies** based on queue metrics
- [ ] **Message compression** for large payloads
- [ ] **Security** with encryption and access control

---

## Level 5: Mastery (45 minutes)

### Case Study: LinkedIn's Kafka Infrastructure

<div class="truth-box">
<h4>🏢 Real-World Implementation</h4>

**Company**: LinkedIn  
**Scale**: 7T messages/day, 100+ clusters, 4K+ brokers, PBs of data

**Challenge**: Real-time pipelines with sub-second latency.

**Architecture**: Producers → Kafka → Stream Processors → Consumers

**Design**:
1. Partition by member ID
2. 3x cross-AZ replication
3. 3-7 day retention
4. Snappy compression

**Optimizations**: Custom partitioning, tiered storage, adaptive batching, zero-copy

**Results**: <10ms p99, 99.99% availability, 30MB/s/broker, <30s recovery

**Lessons**:
1. Monitor everything
2. Thoughtful partitioning
3. Plan for failure
4. Workload-specific tuning
</div>

### Economic Analysis

#### Cost Model

```python
def calculate_queue_roi(
    messages_per_day: int,
    avg_message_size_kb: float,
    peak_to_avg_ratio: float,
    direct_call_failure_rate: float
) -> dict:
    """Calculate ROI for implementing queues"""
    
    # Direct service-to-service costs
    direct_costs = {
        'server_capacity': messages_per_day * peak_to_avg_ratio * 0.0001,
        'failure_handling': messages_per_day * direct_call_failure_rate * 0.01,
        'timeout_overhead': messages_per_day * 0.00001,
        'cascading_failures': direct_call_failure_rate * 10000  # Outage cost
    }
    
    # Queue infrastructure costs
    queue_costs = {
        'queue_service': messages_per_day * avg_message_size_kb * 0.000001,
        'storage': messages_per_day * avg_message_size_kb * 0.0000001,
        'management': 2000,  # Fixed monthly cost
        'monitoring': 500
    }
    
    # Benefits
    benefits = {
        'reduced_server_capacity': direct_costs['server_capacity'] * 0.6,
        'eliminated_failures': direct_costs['cascading_failures'] * 0.95,
        'improved_reliability': 5000,
        'elastic_scaling': direct_costs['server_capacity'] * 0.3
    }
    
    monthly_savings = sum(benefits.values()) - sum(queue_costs.values())
    
    return {
        'monthly_savings': monthly_savings,
        'peak_capacity_reduction': (1 - 1/peak_to_avg_ratio) * 100,
        'reliability_improvement': 99.9,
        'recommended': peak_to_avg_ratio > 3 or direct_call_failure_rate > 0.01
    }

# Example calculation
roi = calculate_queue_roi(
    messages_per_day=10_000_000,
    avg_message_size_kb=10,
    peak_to_avg_ratio=10,  # 10x peak traffic
    direct_call_failure_rate=0.05  # 5% failure rate
)
print(f"ROI: ${roi['monthly_savings']:,.0f}/month, "
      f"Peak reduction: {roi['peak_capacity_reduction']:.0f}%")
```

#### When It Pays Off

- **Break-even**: 3x peak ratio or 1% failure rate
- **High ROI**: Variable traffic, microservices, event-driven, pipelines
- **Low ROI**: Constant low traffic, simple request-response, latency-sensitive gaming

### Pattern Evolution

```mermaid
timeline
    title Evolution of Queue Systems
    
    1950s : IBM Job Entry Systems
          : Batch processing queues
    
    1970s : Message-Oriented Middleware
          : MQSeries (IBM MQ)
    
    1990s : Enterprise Service Bus
          : JMS standard emerges
    
    2000s : Internet-scale queues
          : Amazon SQS, RabbitMQ
    
    2010 : Distributed logs
         : Kafka changes the game
    
    2015 : Streaming platforms
         : Real-time stream processing
    
    2020 : Serverless queues
         : Event-driven architectures
    
    2025 : Current State
         : Multi-cloud streaming
         : Edge message routing
```

### Law Connections

<div class="law-box">
<h4>🔗 Fundamental Laws</h4>

This pattern directly addresses:

1. **[Law 4 (Multidimensional Optimization ⚖️)](../part1-axioms/law4-tradeoffs/index.md)**: Buffers handle capacity mismatches
2. **[Law 2 (Asynchronous Reality ⏳)](../part1-axioms/law2-asynchrony/index.md)**: Decoupling reduces blocking
3. **[Law 1 (Correlated Failure ⛓️)](../part1-axioms/law1-failure/index.md)**: Messages survive consumer failures
4. **[Law 4 (Multidimensional Optimization ⚖️)](../part1-axioms/law4-tradeoffs/index.md)**: Async coordination via messages
5. **[Law 5 (Distributed Knowledge 🧠)](../part1-axioms/law5-epistemology/index.md)**: Message flow visibility
</div>

### Future Directions

**Emerging Trends**:

1. **Edge Queuing**: Message routing at edge locations
2. **ML-Driven Routing**: Smart message routing based on content
3. **Quantum-Safe Queues**: Post-quantum encryption for messages
4. **Cross-Cloud Streaming**: Seamless multi-cloud message flow

**What's Next**:
- Automatic queue sizing based on traffic patterns
- Self-healing message flows
- Declarative stream processing
- Zero-latency message passing for critical paths

---

## Quick Reference

### Decision Matrix

```mermaid
graph TD
    Start[Need async processing?] --> Q1{Variable<br/>load?}
    Q1 -->|No| Q2{Multiple<br/>consumers?}
    Q1 -->|Yes| UseQueue[Use Queue/Stream]
    
    Q2 -->|No| Q3{Failure<br/>tolerance?}
    Q2 -->|Yes| UseQueue
    
    Q3 -->|No| Direct[Use direct calls]
    Q3 -->|Yes| UseQueue
    
    UseQueue --> Q4{Need<br/>ordering?}
    Q4 -->|Global| SingleQueue[Single queue/partition]
    Q4 -->|Per-key| Partitioned[Partitioned queue/stream]
    Q4 -->|None| MultiQueue[Multiple queues]
    
    UseQueue --> Q5{Need<br/>replay?}
    Q5 -->|Yes| Stream[Use event stream]
    Q5 -->|No| Queue[Use message queue]
```

### Command Cheat Sheet

```bash
# Queue Operations
queue send <queue> <message>         # Send message
queue receive <queue> --wait=30      # Receive with timeout
queue depth <queue>                  # Check queue size
queue purge <queue>                  # Clear queue

# Stream Operations
stream produce <topic> <key> <value> # Produce event
stream consume <group> <topic>       # Consume as group
stream offset <group> <topic>        # Check consumer lag
stream replay <topic> --from=<time>  # Replay from timestamp

# Monitoring
queue-monitor stats <queue>          # Queue statistics
queue-monitor lag <consumer-group>   # Consumer lag
queue-monitor dlq                    # Dead letter queue

# Management
queue create <name> --size=10000     # Create queue
queue delete <name>                  # Delete queue
queue policy <name> --dlq --retries=3 # Set policies
```

### Configuration Template

```yaml
# Production Queue/Stream configuration
messaging:
  queues:
    default:
      type: "sqs"  # or rabbitmq, redis
      visibility_timeout: 30s
      max_receive_count: 3
      retention_period: 4d
      dlq_enabled: true
      
    high_priority:
      type: "sqs"
      visibility_timeout: 10s
      max_receive_count: 5
      
  streams:
    events:
      type: "kafka"  # or kinesis, pulsar
      partitions: 100
      replication_factor: 3
      retention_ms: 604800000  # 7 days
      compression_type: "snappy"
      
    analytics:
      type: "kafka"
      partitions: 50
      retention_ms: 86400000  # 1 day
      
  consumers:
    batch_size: 100
    parallelism: 10
    error_strategy: "dlq"  # or retry, ignore
    checkpoint_interval: 1000
    
  monitoring:
    metrics_enabled: true
    lag_threshold: 10000
    depth_threshold: 50000
    age_threshold: 300s
```

---

## Related Resources

### Patterns
- [Event-Driven Architecture](../patterns/event-driven.md) - Built on queues/streams
- [CQRS](../patterns/cqrs.md) - Commands via queues
- [Saga Pattern](../patterns/saga.md) - Orchestration via queues
- [Circuit Breaker](../patterns/circuit-breaker.md) - Protect consumers

### Laws
- [Law 4 (Multidimensional Optimization ⚖️)](../part1-axioms/law4-tradeoffs/index.md) - Why buffering matters
- [Law 2 (Asynchronous Reality ⏳)](../part1-axioms/law2-asynchrony/index.md) - Async vs sync trade-offs
- [Law 1 (Correlated Failure ⛓️)](../part1-axioms/law1-failure/index.md) - Message durability

### Further Reading
- [Kafka: The Definitive Guide](https://www.confluent.io/resources/kafka-the-definitive-guide/) - O'Reilly
- [Designing Data-Intensive Applications](https://dataintensive.net/) - Chapter 11 on streams
- [Enterprise Integration Patterns](https://www.enterpriseintegrationpatterns.com/) - Messaging patterns
- [AWS SQS Best Practices](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-best-practices.html)

### Tools & Libraries
- **Message Queues**: RabbitMQ, AWS SQS, Azure Service Bus, Redis
- **Event Streams**: Apache Kafka, AWS Kinesis, Azure Event Hubs, Pulsar
- **Stream Processing**: Apache Flink, Spark Streaming, Kafka Streams
- **Libraries**: 
  - Java: Spring Cloud Stream
  - Python: Celery, aiokafka
  - Go: Sarama, NATS
  - Node.js: Bull, KafkaJS

---

<div class="navigation-links">
<div class="prev-link">
<a href="/patterns/">← Previous: Patterns Overview</a>
</div>
<div class="next-link">
<a href="/patterns/cqrs">Next: CQRS →</a>
</div>
</div>