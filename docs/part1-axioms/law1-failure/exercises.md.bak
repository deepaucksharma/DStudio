---
title: "Failure Engineering Lab: Correlation Analysis & Chaos Experiments"
description: Hands-on exercises to understand and test for correlated failures
type: exercise
difficulty: expert
reading_time: 45 min
prerequisites: ["law1-failure/index.md"]
status: complete
last_updated: 2025-07-23
---

# Failure Engineering Lab: Correlation Analysis & Chaos Experiments

## Exercise 1: Dependency Mapping and Correlation Analysis

### Objective
Map dependencies in a real system and calculate failure correlation coefficients.

### Scenario
You have a microservices architecture with the following components:
- API Gateway (depends on: Auth Service, Rate Limiter)
- Auth Service (depends on: User DB, Redis Cache, Token Service)
- User Service (depends on: User DB, Redis Cache)
- Order Service (depends on: Order DB, User Service, Payment Service)
- Payment Service (depends on: Payment DB, External Payment Gateway)
- All services depend on: Service Mesh, DNS, Logging Service

### Task 1: Build Dependency Graph
```python
# Complete this dependency graph
dependencies = {
    'api_gateway': ['auth_service', 'rate_limiter', 'service_mesh', 'dns', 'logging'],
    'auth_service': ['user_db', 'redis_cache', 'token_service', 'service_mesh', 'dns', 'logging'],
    # TODO: Complete for all services
}

def calculate_shared_dependencies(service1, service2, deps):
    """Calculate shared dependencies between two services"""
    # TODO: Implement
    pass

def calculate_correlation_coefficient(service1, service2, deps):
    """Calculate failure correlation coefficient (0-1)"""
    # TODO: Implement
    # Hint: Consider both direct and transitive dependencies
    pass
```

### Task 2: Identify Critical Shared Dependencies
Which dependencies, if failed, would cause the most correlated failures?

### Expected Insights
- Service mesh and DNS are critical shared dependencies
- Database sharing creates hidden correlations
- Transitive dependencies amplify correlation

## Exercise 2: Gray Failure Detection

### Objective
Design monitoring to detect gray failures that traditional health checks miss.

### Scenario
Your service has these characteristics:
- Health check endpoint returns 200 OK in < 100ms
- Normal p99 latency: 250ms
- During gray failure: Health check passes, but real requests take 10+ seconds

### Task: Implement Gray Failure Detection
```python
class GrayFailureDetector:
    def __init__(self):
        self.latency_history = deque(maxlen=1000)
        self.health_check_latency = deque(maxlen=100)
        
    def record_request(self, latency_ms: float, is_health_check: bool):
        """Record request latency"""
        # TODO: Implement
        pass
        
    def detect_gray_failure(self) -> bool:
        """Detect if system is in gray failure state"""
        # TODO: Implement detection logic
        # Hints:
        # - Compare health check latency vs real request latency
        # - Look for bimodal distributions
        # - Check for increasing timeouts despite passing health checks
        pass
        
    def get_reliability_score(self) -> float:
        """Return reliability score (0-1) accounting for gray failures"""
        # TODO: Implement
        pass
```

### Validation
Test your detector with this simulated gray failure:
```python
def simulate_gray_failure():
    detector = GrayFailureDetector()
    
    # Normal operation
    for _ in range(100):
        detector.record_request(random.gauss(200, 50), False)
        detector.record_request(50, True)  # Health check
    
    # Gray failure begins
    for _ in range(100):
        # Real requests severely degraded
        detector.record_request(random.gauss(10000, 2000), False)
        # Health checks still fast
        detector.record_request(50, True)
    
    assert detector.detect_gray_failure() == True
```

## Exercise 3: Metastable Failure Simulation

### Objective
Understand and simulate metastable failures with retry amplification.

### The Model
```python
class MetastableSystem:
    def __init__(self, capacity=1000):
        self.capacity = capacity
        self.current_load = 0
        self.retry_rate = 0
        self.goodput = 0  # Successful requests
        self.in_metastable_state = False
        
    def process_requests(self, incoming_load):
        """Process one time unit of requests"""
        total_load = incoming_load + self.retry_rate
        
        if total_load <= self.capacity * 0.7:
            # Stable state - all requests succeed
            self.goodput = incoming_load
            self.retry_rate = 0
            self.in_metastable_state = False
        elif total_load <= self.capacity:
            # Degraded state - some failures
            success_rate = 1 - (total_load - 0.7 * self.capacity) / (0.3 * self.capacity)
            self.goodput = incoming_load * success_rate
            # Failed requests retry
            self.retry_rate = incoming_load * (1 - success_rate) * 3  # 3x retry
        else:
            # Overload - metastable state
            self.in_metastable_state = True
            # Only process up to capacity
            processed = self.capacity
            # Very low success rate
            success_rate = 0.1
            self.goodput = processed * success_rate
            # Massive retry amplification
            self.retry_rate = (total_load - processed + processed * (1 - success_rate)) * 3
```

### Task: Find the Metastability Threshold
```python
def find_metastability_threshold(system):
    """Find the load level that triggers metastable failure"""
    # TODO: Implement binary search to find threshold
    # Start with low load, gradually increase
    # Detect when system enters metastable state
    pass

def design_retry_strategy():
    """Design a retry strategy that prevents metastable failure"""
    # TODO: Implement adaptive retry with:
    # - Exponential backoff
    # - Jitter
    # - Circuit breaking
    # - Load shedding
    pass
```

## Exercise 4: Chaos Engineering for Correlated Failures

### Objective
Design chaos experiments that test for correlated failures, not just random failures.

### Task: Implement Correlation-Aware Chaos
```python
class CorrelationChaosEngine:
    def __init__(self, infrastructure):
        self.infra = infrastructure
        
    def inject_correlated_failure(self, correlation_type):
        """Inject failures that test correlation resistance"""
        scenarios = {
            'rack_failure': self.fail_entire_rack,
            'az_failure': self.fail_availability_zone,
            'deploy_failure': self.fail_deployment_group,
            'time_bomb': self.trigger_time_based_failure,
            'dependency_failure': self.fail_shared_dependency,
            'gray_failure': self.inject_performance_degradation
        }
        # TODO: Implement each scenario
        
    def fail_entire_rack(self, rack_id):
        """Simulate power/network failure for entire rack"""
        # TODO: Implement
        # Should fail all services in the rack
        # Test if system maintains availability
        pass
        
    def trigger_time_based_failure(self):
        """Simulate certificate expiry or time-based bug"""
        # TODO: Implement
        # Fail all services using same certificate
        # Or trigger leap-second style bug
        pass
        
    def measure_blast_radius(self, failure_scenario):
        """Measure the impact radius of a failure"""
        # TODO: Implement metrics:
        # - Number of services affected
        # - Customer impact percentage
        # - Time to recovery
        # - Whether failure cascaded
        pass
```

### Validation Criteria
Your chaos experiments should verify:
1. No single rack failure causes > 10% service degradation
2. No single AZ failure causes > 33% service degradation  
3. Time-based failures don't affect all regions simultaneously
4. Shared dependency failures trigger circuit breakers, not cascades

## Exercise 5: Building a Correlation-Resistant Architecture

### Objective
Design a system architecture that minimizes failure correlation.

### Requirements
- 99.99% availability target
- Must survive any single AZ failure
- Must survive correlated software failures
- Must prevent cascade failures

### Task: Design the Architecture
```yaml
# Complete this architecture design
architecture:
  cells:
    - cell_id: "cell-1"
      region: "us-east-1"
      azs: ["us-east-1a", "us-east-1b"]
      capacity_percent: 35
      # TODO: Define isolation boundaries
      
  anti_correlation_strategies:
    deployment:
      # TODO: Define deployment strategy to prevent correlated software failures
    
    dependencies:
      # TODO: Define how to break dependency correlations
    
    data:
      # TODO: Define data replication strategy
    
  failure_domains:
    # TODO: Define hierarchical failure domains
    
  bulkheads:
    # TODO: Define isolation mechanisms
```

### Bonus: Economic Analysis
Calculate the cost of correlation resistance:
- Additional infrastructure for cells: $X
- Complexity cost (engineering hours): $Y
- Prevented outage cost: $Z
- ROI = ?

## Exercise 6: Post-Mortem Analysis

### Objective
Analyze a real correlated failure and design preventions.

### Case Study: The S3 Outage of 2017
Read the [AWS S3 outage post-mortem](https://aws.amazon.com/message/41926/) and answer:

1. What type of failure was this? (Categorize using our taxonomy)
2. How did the failure correlate across services?
3. What dependency wasn't properly isolated?
4. Design three specific mechanisms that would have prevented this

### Your Analysis Template
```markdown
## Failure Type
- [ ] Correlated Hardware
- [ ] Gray Failure  
- [ ] Metastable
- [ ] Cascading
- [ ] Software Correlation

## Root Cause

## Correlation Mechanism

## Prevention Strategies
1. 
2.
3.

## Monitoring That Would Have Caught This

## Chaos Experiment to Validate Fix
```

## Synthesis Questions

After completing these exercises, you should be able to answer:

1. **Why is the independence assumption dangerous?**
2. **How do you measure failure correlation in a running system?**
3. **What's the difference between preventing failures and preventing correlation?**
4. **Why do metastable failures require manual intervention?**
5. **How do you test for failures you haven't imagined?**

## Additional Challenges

1. **Build a Correlation Detector**: Create a service that continuously monitors for emerging correlations in production
2. **Design a Game Day**: Plan a full correlation-focused game day for your organization
3. **Cost Model**: Build a model that quantifies the cost of correlation vs the cost of preventing it

[**← Back to Law of Failure**](index.md) | [**→ Next: Law of Asynchrony Exercises**](../law2-asynchrony/exercises.md)