<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Distributed Systems - Visual Table of Contents</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #0a0e27;
            color: #e0e6ed;
            padding: 20px;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
        }

        /* Journey Map Container */
        .journey-container {
            background: rgba(26, 32, 44, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 16px;
            padding: 2rem;
            margin-bottom: 2rem;
            overflow-x: auto;
        }

        #journey-map {
            min-width: 1200px;
            height: 800px;
        }

        /* Nodes styling */
        .node {
            cursor: pointer;
        }

        .node-rect {
            fill: #1a202c;
            stroke: #667eea;
            stroke-width: 2;
            rx: 8;
            transition: all 0.2s ease;
        }

        .node:hover .node-rect {
            fill: #2d3748;
            stroke: #764ba2;
            stroke-width: 3;
            filter: drop-shadow(0 0 20px rgba(102, 126, 234, 0.6));
        }

        .node-text {
            fill: #e0e6ed;
            font-size: 13px;
            font-weight: 600;
            pointer-events: none;
        }

        .node-subtext {
            fill: #a0aec0;
            font-size: 11px;
            pointer-events: none;
        }

        .link {
            fill: none;
            stroke: #4a5568;
            stroke-width: 2;
            opacity: 0.6;
        }

        /* Expanded state */
        .node.expanded .node-rect {
            fill: #2d3748;
            stroke: #10b981;
        }

        /* Node types */
        .node.axiom .node-rect { stroke: #667eea; }
        .node.practice .node-rect { stroke: #10b981; }
        .node.deep-dive .node-rect { stroke: #f59e0b; }
        .node.case-study .node-rect { stroke: #ef4444; }
        .node.content .node-rect { stroke: #8b5cf6; }

        /* Summary Box */
        .summary-box {
            background: rgba(26, 32, 44, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 16px;
            padding: 2rem;
        }

        .summary-title {
            font-size: 1.5rem;
            font-weight: bold;
            margin-bottom: 1rem;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .summary-content {
            color: #a0aec0;
            line-height: 1.6;
        }

        .summary-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1rem;
            margin-top: 1.5rem;
        }

        .summary-item {
            background: rgba(10, 14, 39, 0.5);
            padding: 1rem;
            border-radius: 8px;
            border: 1px solid rgba(102, 126, 234, 0.3);
        }

        .summary-item h3 {
            color: #667eea;
            font-size: 0.9rem;
            margin-bottom: 0.5rem;
        }

        .summary-item p {
            font-size: 0.85rem;
        }

        /* Legend */
        .legend {
            display: flex;
            gap: 2rem;
            margin-bottom: 1rem;
            font-size: 0.85rem;
            color: #a0aec0;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 4px;
        }

        /* Tooltip */
        .tooltip {
            position: absolute;
            padding: 0.75rem 1rem;
            background: rgba(26, 32, 44, 0.95);
            border: 1px solid rgba(102, 126, 234, 0.5);
            border-radius: 8px;
            color: #e0e6ed;
            font-size: 0.9rem;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 1000;
            max-width: 300px;
        }

        .tooltip.active {
            opacity: 1;
        }

        /* Selected node details */
        .node-details {
            margin-top: 1.5rem;
            padding: 1rem;
            background: rgba(10, 14, 39, 0.5);
            border-radius: 8px;
            border: 1px solid rgba(102, 126, 234, 0.3);
        }

        .node-details h3 {
            color: #667eea;
            margin-bottom: 0.5rem;
        }

        .node-details p {
            color: #a0aec0;
            margin-bottom: 0.5rem;
        }

        .node-details ul {
            list-style: none;
            padding-left: 0;
        }

        .node-details li {
            color: #a0aec0;
            padding: 0.25rem 0;
        }

        .node-details li:before {
            content: "â†’ ";
            color: #667eea;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Journey Map -->
        <div class="journey-container">
            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color" style="background: #667eea;"></div>
                    <span>Core Axiom</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #10b981;"></div>
                    <span>Practice/Implementation</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #f59e0b;"></div>
                    <span>Deep Dive Content</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #ef4444;"></div>
                    <span>Case Study</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #8b5cf6;"></div>
                    <span>Theory/Content</span>
                </div>
            </div>
            <svg id="journey-map"></svg>
        </div>

        <!-- Summary Box -->
        <div class="summary-box" id="summaryBox">
            <h2 class="summary-title">Distributed Systems: From Theory to Practice</h2>
            <div class="summary-content">
                <p>A comprehensive journey through the fundamental axioms that govern distributed systems at scale. Each concept builds upon the previous, illustrated with real-world failures and practical implementations.</p>
                
                <div class="summary-grid">
                    <div class="summary-item">
                        <h3>ðŸŽ¯ Learning Path</h3>
                        <p>8 core axioms, 20+ case studies, 50+ patterns organized in a logical progression from basic concepts to advanced implementations.</p>
                    </div>
                    <div class="summary-item">
                        <h3>âš¡ Interactive Learning</h3>
                        <p>Click any node to explore deeper. Each axiom includes practical exercises, real-world examples, and implementation details.</p>
                    </div>
                    <div class="summary-item">
                        <h3>ðŸ”§ Hands-On Practice</h3>
                        <p>Every concept paired with coding exercises, system design problems, and production-ready patterns.</p>
                    </div>
                    <div class="summary-item">
                        <h3>ðŸ“Š Real-World Focus</h3>
                        <p>Learn from actual outages at Netflix, Uber, Amazon. Understand not just the theory but the practice.</p>
                    </div>
                </div>
                
                <div id="selectedNodeDetails"></div>
            </div>
        </div>
    </div>

    <!-- Tooltip -->
    <div class="tooltip" id="tooltip"></div>

    <script>
        // Comprehensive table of contents data
        const tableOfContents = {
            name: "Distributed Systems Mastery",
            type: "root",
            children: [
                {
                    name: "Axiom 1: Network Is Slow",
                    type: "axiom",
                    id: "network-slow",
                    description: "Network latency dominates - 6 orders of magnitude slower than memory",
                    children: [
                        {
                            name: "Latency Numbers",
                            type: "content",
                            description: "L1 cache: 0.5ns, Network: 500Î¼s, Cross-region: 150ms",
                            topics: ["Hardware basics", "Network RTT", "Speed of light limits"]
                        },
                        {
                            name: "Batching & Compression",
                            type: "practice",
                            description: "Reduce network calls through batching, use compression wisely",
                            examples: ["GraphQL vs REST", "Protocol Buffers", "HTTP/2 multiplexing"]
                        },
                        {
                            name: "Netflix CDN Strategy",
                            type: "case-study",
                            description: "How Netflix serves 167M users with edge caching",
                            lessons: ["Open Connect", "ISP partnerships", "Predictive caching"]
                        },
                        {
                            name: "Database Internals",
                            type: "deep-dive",
                            description: "From magnetic disks to B-trees - why databases are slow",
                            link: "/content/databases-from-first-principles"
                        }
                    ]
                },
                {
                    name: "Axiom 2: Queues Everywhere",
                    type: "axiom",
                    id: "queues-everywhere",
                    description: "Little's Law rules - systems cliff at high utilization",
                    children: [
                        {
                            name: "Little's Law",
                            type: "content",
                            description: "L = Î»W: The fundamental equation of queuing theory",
                            topics: ["Queue math", "Utilization curves", "Response time"]
                        },
                        {
                            name: "The Saturation Cliff",
                            type: "practice",
                            description: "At 95% utilization, wait time = 19x service time",
                            examples: ["CPU scheduling", "Thread pools", "Connection pools"]
                        },
                        {
                            name: "Uber Surge Pricing",
                            type: "case-study",
                            description: "Managing queues through dynamic pricing",
                            lessons: ["Demand shaping", "Driver utilization", "Market equilibrium"]
                        },
                        {
                            name: "Queue Implementations",
                            type: "deep-dive",
                            description: "Kafka, RabbitMQ, SQS - choosing the right queue",
                            patterns: ["At-least-once", "Exactly-once", "Ordering guarantees"]
                        }
                    ]
                },
                {
                    name: "Axiom 3: Partial Failure",
                    type: "axiom",
                    id: "partial-failure",
                    description: "Systems work AND are broken simultaneously",
                    children: [
                        {
                            name: "Failure Modes",
                            type: "content",
                            description: "Slow, intermittent, asymmetric, and gray failures",
                            topics: ["Byzantine failures", "Network partitions", "Silent corruption"]
                        },
                        {
                            name: "Resilience Patterns",
                            type: "practice",
                            description: "Circuit breakers, bulkheads, timeouts, retries",
                            examples: ["Hystrix", "Resilience4j", "Envoy proxy"]
                        },
                        {
                            name: "2022 Retry Storm",
                            type: "case-study",
                            description: "How one slow DB caused complete outage",
                            lessons: ["Cascading failures", "Retry amplification", "Backpressure"]
                        },
                        {
                            name: "Chaos Engineering",
                            type: "deep-dive",
                            description: "Proactively finding failures before they find you",
                            tools: ["Chaos Monkey", "Gremlin", "Litmus"]
                        }
                    ]
                },
                {
                    name: "Axiom 4: Concurrency Chaos",
                    type: "axiom",
                    id: "concurrency-chaos",
                    description: "Concurrent operations create non-sequential states",
                    children: [
                        {
                            name: "Race Conditions",
                            type: "content",
                            description: "When timing determines correctness",
                            topics: ["Memory models", "Happens-before", "Atomic operations"]
                        },
                        {
                            name: "Coordination Patterns",
                            type: "practice",
                            description: "Locks, CAS, MVCC, and lock-free algorithms",
                            examples: ["Database isolation levels", "Optimistic locking", "STM"]
                        },
                        {
                            name: "Double-Booked Seat",
                            type: "case-study",
                            description: "Airline's $40M race condition",
                            lessons: ["Distributed locks", "Compensating transactions", "Saga pattern"]
                        },
                        {
                            name: "Consensus Algorithms",
                            type: "deep-dive",
                            description: "Paxos, Raft, and Byzantine consensus",
                            implementations: ["etcd", "Consul", "Zookeeper"]
                        }
                    ]
                },
                {
                    name: "Axiom 5: Coordination Cost",
                    type: "axiom",
                    id: "coordination-cost",
                    description: "Every sync point reduces availability and increases latency",
                    children: [
                        {
                            name: "Cost Analysis",
                            type: "content",
                            description: "Communication + Consensus + Failure handling costs",
                            topics: ["2PC overhead", "Quorum systems", "Gossip protocols"]
                        },
                        {
                            name: "Avoiding Coordination",
                            type: "practice",
                            description: "CRDTs, event sourcing, and eventual consistency",
                            examples: ["Riak", "Cassandra", "DynamoDB"]
                        },
                        {
                            name: "$2M Transaction Cost",
                            type: "case-study",
                            description: "Financial firm's cross-region 2PC nightmare",
                            lessons: ["Regional aggregation", "Eventual consistency", "Cost models"]
                        }
                    ]
                },
                {
                    name: "Axiom 6: CAP Reality",
                    type: "axiom",
                    id: "cap-reality",
                    description: "Partition tolerance isn't optional - choose CP or AP",
                    children: [
                        {
                            name: "CAP Theorem",
                            type: "content",
                            description: "Why you can't have all three",
                            topics: ["Formal proof", "PACELC extension", "Harvest/Yield"]
                        },
                        {
                            name: "System Trade-offs",
                            type: "practice",
                            description: "When to choose CP vs AP",
                            examples: ["HBase (CP)", "Cassandra (AP)", "Spanner (CA with bounds)"]
                        }
                    ]
                },
                {
                    name: "Axiom 7: Time Is Relative",
                    type: "axiom",
                    id: "time-relative",
                    description: "No global 'now' - only causality matters",
                    children: [
                        {
                            name: "Logical Time",
                            type: "content",
                            description: "Lamport timestamps and vector clocks",
                            topics: ["Causality", "Concurrent events", "Clock skew"]
                        },
                        {
                            name: "Google Spanner",
                            type: "case-study",
                            description: "Using atomic clocks for global consistency",
                            lessons: ["TrueTime API", "Uncertainty bounds", "External consistency"]
                        }
                    ]
                },
                {
                    name: "Axiom 8: State Management",
                    type: "axiom",
                    id: "state-management",
                    description: "State is the root of complexity - minimize and isolate",
                    children: [
                        {
                            name: "State Patterns",
                            type: "content",
                            description: "Event sourcing, CQRS, and stateless services",
                            topics: ["Immutability", "Append-only logs", "Materialized views"]
                        },
                        {
                            name: "Scaling State",
                            type: "practice",
                            description: "Sharding, replication, and caching strategies",
                            examples: ["Consistent hashing", "Read replicas", "Write-through cache"]
                        }
                    ]
                }
            ]
        };

        // Initialize D3
        const margin = {top: 40, right: 120, bottom: 40, left: 120};
        const width = 1400;
        const height = 800;

        const svg = d3.select("#journey-map")
            .attr("width", width)
            .attr("height", height)
            .append("g")
            .attr("transform", `translate(${margin.left},${margin.top})`);

        const treeWidth = width - margin.left - margin.right;
        const treeHeight = height - margin.top - margin.bottom;

        // Create tree layout - horizontal for better space usage
        const tree = d3.tree()
            .size([treeHeight, treeWidth])
            .nodeSize([50, 250]) // Fixed node size for consistent spacing
            .separation((a, b) => a.parent == b.parent ? 1 : 1.5);

        // Create hierarchy
        const root = d3.hierarchy(tableOfContents);
        
        // Initially collapse all except root and axioms
        root.descendants().forEach(d => {
            if (d.depth > 1) {
                d._children = d.children;
                d.children = null;
            }
            d.data.nodeId = `${d.data.type}-${d.data.name.replace(/\s+/g, '-')}`;
        });

        // Update function
        function update(source) {
            // Compute the new tree layout
            const treeData = tree(root);

            // Normalize for fixed-depth
            treeData.descendants().forEach(d => {
                d.y = d.depth * 250; // Fixed horizontal spacing
            });

            // Update links
            const links = svg.selectAll(".link")
                .data(treeData.links(), d => d.target.data.nodeId);

            // Remove exiting links
            links.exit()
                .transition()
                .duration(500)
                .style("opacity", 0)
                .remove();

            // Enter new links
            const linksEnter = links.enter().append("path")
                .attr("class", "link")
                .style("fill", "none")
                .style("stroke", "#4a5568")
                .style("stroke-width", 2)
                .style("opacity", 0)
                .attr("d", d => {
                    const o = {x: source.x0, y: source.y0};
                    return diagonal({source: o, target: o});
                });

            // Update links
            links.merge(linksEnter)
                .transition()
                .duration(500)
                .style("opacity", 0.6)
                .attr("d", diagonal);

            // Update nodes
            const nodes = svg.selectAll(".node")
                .data(treeData.descendants(), d => d.data.nodeId);

            // Remove exiting nodes
            nodes.exit()
                .transition()
                .duration(500)
                .style("opacity", 0)
                .attr("transform", d => `translate(${source.y0},${source.x0})`)
                .remove();

            // Enter new nodes
            const nodeEnter = nodes.enter().append("g")
                .attr("class", d => `node ${d.data.type}`)
                .attr("transform", d => `translate(${source.y0},${source.x0})`)
                .style("opacity", 0);

            // Add rectangles
            nodeEnter.append("rect")
                .attr("class", "node-rect")
                .attr("width", d => {
                    if (d.depth === 0) return 200;
                    if (d.depth === 1) return 180;
                    return 160;
                })
                .attr("height", 40)
                .attr("x", d => {
                    if (d.depth === 0) return -100;
                    if (d.depth === 1) return -90;
                    return -80;
                })
                .attr("y", -20)
                .on("click", (event, d) => {
                    event.stopPropagation();
                    toggleNode(d);
                });

            // Add text
            nodeEnter.append("text")
                .attr("class", "node-text")
                .attr("dy", "0.35em")
                .attr("text-anchor", "middle")
                .text(d => {
                    if (d.data.name.length > 30) {
                        return d.data.name.substring(0, 30) + "...";
                    }
                    return d.data.name;
                });

            // Add subtitles for axioms
            nodeEnter.filter(d => d.data.type === "axiom")
                .append("text")
                .attr("class", "node-subtext")
                .attr("dy", "1.5em")
                .attr("text-anchor", "middle")
                .text(d => d.data.id);

            // Update all nodes
            const nodeUpdate = nodes.merge(nodeEnter)
                .transition()
                .duration(500)
                .style("opacity", 1)
                .attr("transform", d => `translate(${d.y},${d.x})`);

            nodeUpdate.select(".node-rect")
                .style("fill", d => d._children ? "#2d3748" : "#1a202c");

            // Store old positions for transition
            nodes.merge(nodeEnter).each(d => {
                d.x0 = d.x;
                d.y0 = d.y;
            });

            // Add hover events
            nodes.merge(nodeEnter)
                .on("mouseenter", (event, d) => showTooltip(event, d))
                .on("mouseleave", hideTooltip)
                .on("click", (event, d) => showNodeDetails(d));
        }

        // Diagonal link generator
        function diagonal(d) {
            return `M ${d.source.y} ${d.source.x}
                    C ${(d.source.y + d.target.y) / 2} ${d.source.x},
                      ${(d.source.y + d.target.y) / 2} ${d.target.x},
                      ${d.target.y} ${d.target.x}`;
        }

        function toggleNode(d) {
            if (d.children) {
                d._children = d.children;
                d.children = null;
            } else {
                d.children = d._children;
                d._children = null;
            }
            update(d);
        }

        // Tooltip functions
        function showTooltip(event, d) {
            const tooltip = document.getElementById("tooltip");
            if (d.data.description) {
                tooltip.innerHTML = `
                    <strong>${d.data.name}</strong><br>
                    ${d.data.description}
                `;
                tooltip.style.left = event.pageX + 10 + "px";
                tooltip.style.top = event.pageY - 30 + "px";
                tooltip.classList.add("active");
            }
        }

        function hideTooltip() {
            document.getElementById("tooltip").classList.remove("active");
        }

        // Show node details
        function showNodeDetails(d) {
            const detailsDiv = document.getElementById("selectedNodeDetails");
            if (d.depth === 0) return; // Don't show details for root

            let html = `<div class="node-details">
                <h3>${d.data.name}</h3>
                <p>${d.data.description}</p>`;

            if (d.data.topics) {
                html += `<p><strong>Topics:</strong></p><ul>`;
                d.data.topics.forEach(topic => {
                    html += `<li>${topic}</li>`;
                });
                html += `</ul>`;
            }

            if (d.data.examples) {
                html += `<p><strong>Examples:</strong></p><ul>`;
                d.data.examples.forEach(example => {
                    html += `<li>${example}</li>`;
                });
                html += `</ul>`;
            }

            if (d.data.lessons) {
                html += `<p><strong>Key Lessons:</strong></p><ul>`;
                d.data.lessons.forEach(lesson => {
                    html += `<li>${lesson}</li>`;
                });
                html += `</ul>`;
            }

            if (d.data.patterns) {
                html += `<p><strong>Patterns:</strong></p><ul>`;
                d.data.patterns.forEach(pattern => {
                    html += `<li>${pattern}</li>`;
                });
                html += `</ul>`;
            }

            if (d.data.tools) {
                html += `<p><strong>Tools:</strong></p><ul>`;
                d.data.tools.forEach(tool => {
                    html += `<li>${tool}</li>`;
                });
                html += `</ul>`;
            }

            if (d.data.implementations) {
                html += `<p><strong>Implementations:</strong></p><ul>`;
                d.data.implementations.forEach(impl => {
                    html += `<li>${impl}</li>`;
                });
                html += `</ul>`;
            }

            html += `</div>`;
            detailsDiv.innerHTML = html;
        }

        // Initial render
        root.x0 = treeHeight / 2;
        root.y0 = 0;
        update(root);
    </script>
</body>
</html>